include "Tlbx MoreFilesX.incl"include resources "1st stage background.png"include resources "2nd stage background.png"include resources "Apple.png"include resources "Cloud quad.png"include resources "Cloud single.png"include resources "Dirt block.png"include resources "Grass block.png"include resources "Many spike DOWN.png"include resources "Many spike LEFT.png"include resources "Many spike RIGHT.png"include resources "Save GREEN.png"include resources "Save RED.png"include resources "Spike DOWN.png"include resources "Spike LEFT.png"include resources "Spike RIGHT.png"include resources "Spike UP.png"include resources "Stone block.png"include resources "Stone floor block.png"include resources "The kid LEFT.png"include resources "The kid RIGHT.png"include resources "Tree.png"include resources "Level 1 Blocks.txt"local fn ResourceImageToPICTHandle( imageName as CFStringRef, imageRect as ^rect ) as handle'~'1dim as GraphicsImportComponent gi dim as ComponentResultÊÊÊÊÊÊÊÊ resultdim as PicHandleÊÊÊÊÊÊÊÊÊÊÊÊÊÊ pictH : pictH = NULLdim as CFURLRefÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ urldim as FSRefÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ fsRefdim as FSSpecÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ fsSpecdim as OSErrÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ errdim as BooleanÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ successurl = fn CFBundleCopyResourceURL( fn CFBundleGetMainBundle(), imageName, 0, 0 )long if ( url )success = fn CFURLGetFSRef( url, @fsRef )CFRelease( url )long if ( success )err = fn FSGetCatalogInfo( @fsRef, _kFSCatInfoNone, NULL, NULL, #fsSpec, NULL )long if ( err == _noErr )err = fn GetGraphicsImporterForFile( fsSpec, gi )long if ( err == _noErr )result = fn GraphicsImportGetAsPicture( gi, pictH )result = fn GraphicsImportGetBoundsRect( gi, #imageRect )err = fn CloseComponent( gi )end ifend ifend ifend ifend fn = (handle)pictHÊÊÊÊ // User must disposedim as handle pictHdim as rectÊÊ rDIM lastDir AS STR255DIM hitX1 AS SHORTDIM hitY1 AS SHORTDIM hitX2 AS SHORTDIM hitY2 AS SHORTDIM distanceCheck AS SHORTDIM randInt AS SHORTDIM inkey AS STR255DIM heightCounter AS SHORTDIM inkeyFill AS STR255DIM upDown AS STR255DIM game AS STR255DIM score AS SHORTDIM loopCycle AS SHORTDIM scoreCheck AS STR255DIM leftRight AS STR255DIM jumpNo AS SHORTDIM tempJump AS SHORTDIM index1 AS SHORTDIM index2 AS SHORTDIM blocks1(25,19) AS STR255DIM blocks2(25,19) AS STR255DIM object AS STR255DIM fPath AS CFURLREFDIM fPath2 AS CFURLREFDIM fPath3 AS CFURLREFDIM active1 AS BOOLEANDIM active2 AS BOOLEANDIM activeCounter AS SHORTDIM firstTime AS BOOLEANDIM bul1X AS SHORTDIM bul1Y AS SHORTDIM bul2X AS SHORTDIM bul2Y AS SHORTDIM bul3X AS SHORTDIM bul3Y AS SHORTDIM bulDir1 AS STR255DIM bulDir2 AS STR255DIM bulDir3 AS STR255DIM bul1Flag AS STR255DIM hitBrickX AS STR255DIM hitBrickY AS STR255DIM prevCheck AS STR255DIM replacementBlockX1 AS SHORTDIM replacementBlockX2 AS SHORTDIM replacementBlockY1 AS SHORTDIM replacementBlockY2 AS SHORTDIM level AS SHORTDIM spikeMoving AS STR255DIM spikeMoving1X1 AS SHORTDIM spikeMoving1X2 AS SHORTDIM spikeMoving1Y1 AS SHORTDIM spikeMoving1Y2 AS SHORTDIM spikeMoving2X1 AS SHORTDIM spikeMoving2X2 AS SHORTDIM spikeMoving2Y1 AS SHORTDIM spikeMoving2Y2 AS SHORTDIM spikeMoving3X1 AS SHORTDIM spikeMoving3X2 AS SHORTDIM spikeMoving3Y1 AS SHORTDIM spikeMoving3Y2 AS SHORTDIM triggered AS STR255DIM spikeGoBack1 AS STR255DIM spikeGoBack2 AS STR255DIM spikeGoBack3 AS STR255DIM moveBackDelay1 AS SHORTDIM moveBackDelay2 AS SHORTDIM moveBackDelay3 AS SHORTDIM death AS STR255DIM spawnLocX1 AS SHORTDIM spawnLocX2 AS SHORTDIM spawnLocY1 AS SHORTDIM spawnLocY2 AS SHORTDIM currenttriggerY AS SHORTWINDOW 1, @"IWBTG", (0,0) - (600,456)LET level = 1/*LET fpath = OSPANELOPEN(,@"Select room 1", @"txt",@"Open",)LET fpath2 = OSPANELOPEN(,@"Select room 2", @"txt",@"Open",)*//*LET fPath3 = OSPANELOPEN(,@"Select save file", @"txt",@"Open",)OPEN "I",3, @fPath3READ #3, spawnLocX1, spawnLocX2, spawnLocY1, spawnLocY2CLOSE #3*///starting position for characterLET spawnLocX1 = 25LET spawnLocX2 = 48LET spawnLocY1 = 49LET spawnLocY2 = 72LET fPath3 = OSPANELOPEN(,@"Select save file", @"txt",@"Open",)OPEN "I",3, @fPath3READ #3, spawnLocX1, spawnLocX2, spawnLocY1, spawnLocY2CLOSE #3LET hitX1 = spawnLocX1LET hitX2 = spawnLocX2LET hitY1 = spawnLocY1LET hitY2 = spawnLocY2LET triggered = "na"LET fpath = OSPANELOPEN(,@"Select room 1", @"txt",@"Open",)LET fpath2 = OSPANELOPEN(,@"Select room 2", @"txt",@"Open",)OPEN "I",1, @fPathFOR index2 = 1 TO 19 STEP 1FOR index1 = 1 TO 25 STEP 1SELECT levelREAD #1, object; 5END SELECTLET blocks1(index1,index2) = objectNEXTNEXTCLOSE #1OPEN "I",2, @fPath2FOR index2 = 1 TO 19 STEP 1FOR index1 = 1 TO 25 STEP 1SELECT levelREAD #2, object; 5END SELECTLET blocks2(index1,index2) = objectNEXTNEXTCLOSE #2GOSUB "Draw"//opening file and reading the level into the 2d array//start of play loopDOIF hitY1 > 0 AND hitY2 < 450//updown is the variable which stores whether the character is moving up or down.SELECT upDown//if the character is moving upCASE "up"IF jumpNo = 1//comparing character to block that he is in to check if there is a brick or something that could kill him.SELECT levelCASE 1IF blocks1(hitX1/24 + 1,hitY2/24) <> "brick"COLOR _zWhiteBOX FILL hitX1,hitY1 TO hitX2,hitY2//changing positionhitY1 -= 6hitY2 -= 6heightCounter += 1END IFCASE 2IF blocks1(hitX1/24 + 1,hitY2/24) <> "brick"COLOR _zWhiteBOX FILL hitX1,hitY1 TO hitX2,hitY2//changing positionhitY1 -= 6hitY2 -= 6heightCounter += 1END IFEND SELECT//checking if the character has hit a block or has reached the top of the jumpSELECT levelCASE 1IF heightCounter = 12 OR blocks1(hitX1/24 + 1,hitY2/24) = "brick"LET heightCounter = 0hitY1 += 6hitY2 += 6//because we are at the top of jump now we need to fall until we hit a block.LET upDown = "down"END IFCASE 2IF heightCounter = 12 OR blocks2(hitX1/24 + 1,hitY2/24) = "brick"LET heightCounter = 0hitY1 += 6hitY2 += 6//because we are at the top of jump now we need to fall until we hit a block.LET upDown = "down"END IFEND SELECTEND IF//filling in previous position with white boxIF jumpNo > 1COLOR _zWhiteSELECT levelCASE 1IF blocks1(hitX1/24 + 1,hitY2/24) <> "brick"BOX FILL hitX1,hitY1 TO hitX2,hitY2hitY1 -= 6hitY2 -= 6heightCounter += 1END IFCASE 2IF blocks2(hitX1/24 + 1,hitY2/24) <> "brick"BOX FILL hitX1,hitY1 TO hitX2,hitY2hitY1 -= 6hitY2 -= 6heightCounter += 1END IFEND SELECT//second jump is doesnt go as high as first jump hence the 8 move cycle vs 12 for regular jumpSELECT level CASE 1IF heightCounter = 8 OR blocks1(hitX1/24 + 1,hitY2/24) = "brick"LET heightCounter = 0LET upDown = "down"hitY1 += 6hitY2 += 6END IFCASE 2IF heightCounter = 8 OR blocks2(hitX1/24 + 1,hitY2/24) = "brick"LET heightCounter = 0LET upDown = "down"hitY1 += 6hitY2 += 6END IFEND SELECTEND IF//movement for fallingCASE "down"/*IF jumpNo = 1*/COLOR _zWhite//checking if position is unobstructed and moving down and filling last position with white boxSELECT levelCASE 1IF blocks1(hitX1/24 + 1,hitY1/24 + 2) <> "brick"BOX FILL hitX1,hitY1 TO hitX2,hitY2hitY1 += 6hitY2 +=6END IFCASE 2IF blocks2(hitX1/24 + 1,hitY1/24 + 2) <> "brick"BOX FILL hitX1,hitY1 TO hitX2,hitY2hitY1 += 6hitY2 +=6END IFEND SELECT//checking either if you have hit a block or if you have SELECT level CASE 1IF blocks1(hitX1/24 + 1,hitY1/24 + 2) = "brick"LET upDown = ""LET inkeyFill = ""LET jumpNo = 0END IFCASE 2IF blocks2(hitX1/24 + 1,hitY1/24 + 2) = "brick"LET upDown = ""LET inkeyFill = ""LET jumpNo = 0END IFEND SELECT/*END IF*///if you have used your second jump and you havent landed yet bring the position down the screen. and fills in last position with white box./*IF jumpNo >= 2 AND hitY1 < tempJumpCOLOR _zWhiteIF blocks(hitX1/24 + 1,hitY1/24 + 2) <> "brick"BOX FILL hitX1,hitY1 TO hitX2,hitY2hitY1 += 6hitY2 +=6END IF//stop if you hit a brickIF blocks(hitX1/24 + 1,hitY1/24 + 2) = "brick"LET upDown = ""LET inkeyFill = ""LET jumpNo = 0END IFEND IF*/END SELECT//movement side to sideSELECT leftRightCASE "a"COLOR _zWhite//filling last position adding left and right movement to the coordinates of the characterIF ((hitX2-12)/24) =>0 SELECT levelCASE 1//this line makes sure that the block to the left of the character is positive as in it isnt off the screenIF blocks1((hitX2-12)/24,hitY2/24) <> "brick" // this checks that the block to the left of the character isnt a brick. if it isnt a brick then the character moves leftBOX FILL hitX1,hitY1 TO hitX2,hitY2hitX1 -= 12hitX2 -= 12LET inkeyFill = ""LET leftRight = ""END IFCASE 2IF blocks2((hitX2-12)/24,hitY2/24) <> "brick" // this checks that the block to the left of the character isnt a brick. if it isnt a brick then the character moves leftBOX FILL hitX1,hitY1 TO hitX2,hitY2hitX1 -= 12hitX2 -= 12LET inkeyFill = ""LET leftRight = ""END IFEND SELECTEND IF//setting last direction for shooting directionLET lastDir = "a"CASE "d"COLOR _zWhite//filling last position adding left and right movement to the coordinates of the characterSELECT levelCASE 1IF blocks1((hitX2/24 + 1),hitY1/24) <> "brick"  // this checks that the block to the right of the character isnt a brick. if it isnt a brick then the character moves rightBOX FILL hitX1,hitY1 TO hitX2,hitY2hitX1 += 12hitX2 += 12LET inkeyFill = ""LET leftRight = ""END IFCASE 2IF blocks2((hitX2/24 + 1),hitY1/24) <> "brick"  // this checks that the block to the right of the character isnt a brick. if it isnt a brick then the character moves rightBOX FILL hitX1,hitY1 TO hitX2,hitY2hitX1 += 12hitX2 += 12LET inkeyFill = ""LET leftRight = ""END IFEND SELECT//setting last direction for shooting directionLET lastDir = "d"END SELECT//deciding which picture to print (facing which direction) based on setting before.SELECT lastDirCASE "a"//displaying the left facing imagepictH = fn ResourceImageToPICTHandle( @"The kid LEFT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )CASE "d"//displaying the right facing imagepictH = fn ResourceImageToPICTHandle( @"The kid RIGHT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )END SELECT//if the spike has hit the end and has to move back nowIF spikeGoBack1 = "yep1"//move back delay waits 50 itterations of the loop before moving the spike back after it has hit the end.IF moveBackDelay1 = 50//after the delay and only if the spike hasnt moved back all the wayIF spikeMoving1X1 > 25COLOR _zWhite BOX FILL spikeMoving1X1, spikeMoving1Y1 TO spikeMoving1X2, spikeMoving1Y2 //fill the location//change location back by 2 pixelsLET spikeMoving1X1 -= 2LET spikeMoving1X2 -= 2//reprint the spikepictH = fn ResourceImageToPICTHandle( @"Many spike RIGHT.png", @r )picture (spikeMoving1X1, spikeMoving1Y1) - (spikeMoving1X2, spikeMoving1Y2), pictHfn DisposeH( pictH )ELSE //if you have hit the endLET spikeGoBack1 = "na" //dont move back next itteration of the arrayCOLOR _zWhite BOX FILL spikeMoving1X1, spikeMoving1Y1 TO spikeMoving1X2, spikeMoving1Y2 // fill the location, erasing the spike until it is triggered again.END IFELSE//add to the delayLET moveBackDelay1 +=1END IFEND IF//if the spike has hit the end and has to move back nowIF spikeGoBack2 = "yep2"//move back delay waits 50 itterations of the loop before moving the spike back after it has hit the end.IF moveBackDelay2 = 50//after the delay and only if the spike hasnt moved back all the wayIF spikeMoving2X1 < 552COLOR _zWhite BOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2 //fill the location//change location back by 2 pixelsLET spikeMoving2X1 += 2LET spikeMoving2X2 += 2//reprint the spikepictH = fn ResourceImageToPICTHandle( @"Many spike LEFT.png", @r )picture (spikeMoving2X1, spikeMoving2Y1) - (spikeMoving2X2, spikeMoving2Y2), pictHfn DisposeH( pictH )ELSE //if you have hit the endLET spikeGoBack2 = "na" //dont move back next itteration of the arrayCOLOR _zWhite BOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2 // fill the location, erasing the spike until it is triggered again.END IFELSE//add to the delayLET moveBackDelay2 +=1END IFEND IF// after the spike has been triggeredIF triggered = "lvl1spike1"//and the spike hasnt hit the endIF spikeMoving1X1 < 504COLOR _zWhite BOX FILL spikeMoving1X1, spikeMoving1Y1 TO spikeMoving1X2, spikeMoving1Y2 // fill last location//move forwardLET spikeMoving1X1 += 30LET spikeMoving1X2 += 30//reprint spikespictH = fn ResourceImageToPICTHandle( @"Many spike RIGHT.png", @r )picture (spikeMoving1X1, spikeMoving1Y1) - (spikeMoving1X2, spikeMoving1Y2), pictHfn DisposeH( pictH )END IF// if it has hit the endIF spikeMoving1X1 = 505//start going backLET spikeGoBack1 = "yep1"LET triggered = "na" //reset triggerLET moveBackDelay1 = 0     //reset delayEND IFEND IFIF triggered = "lvl1spike2"//and the spike hasnt hit the endIF spikeMoving2X1 > 73COLOR _zWhite BOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2 // fill last location//move forwardLET spikeMoving2X1 -= 30LET spikeMoving2X2 -= 30//reprint spikespictH = fn ResourceImageToPICTHandle( @"Many spike LEFT.png", @r )picture (spikeMoving2X1, spikeMoving2Y1) - (spikeMoving2X2, spikeMoving2Y2), pictHfn DisposeH( pictH )END IF// if it has hit the endIF spikeMoving2X1 = 72//start going backLET spikeGoBack2 = "yep2"LET triggered = "na" //reset triggerLET moveBackDelay2 = 0     //reset delayEND IFEND IFIF triggered = "lvl1spike3"//and the spike hasnt hit the endIF spikeMoving2X1 > 73COLOR _zWhite BOX FILL spikeMoving3X1, spikeMoving3Y1 TO spikeMoving3X2, spikeMoving3Y2 // fill last location//move forwardLET spikeMoving3X1 -= 30LET spikeMoving3X2 -= 30//reprint spikespictH = fn ResourceImageToPICTHandle( @"Many spike LEFT.png", @r )picture (spikeMoving3X1, spikeMoving3Y1) - (spikeMoving3X2, spikeMoving3Y2), pictHfn DisposeH( pictH )END IF// if it has hit the endIF spikeMoving3X1 = 72LET triggered = "na" //reset triggerCOLOR _zWhite BOX FILL spikeMoving3X1, spikeMoving3Y1 TO spikeMoving3X2, spikeMoving3Y2END IFEND IF//this part is the triggerIF level = 1 AND triggered = "na" AND spikeGoBack1 <> "yep1" LET currenttriggerY = hitY2/24//only triggers if you are on the right level it has not already been triggered and it isnt going back.IF currenttriggerY = 7//if you are in the right y locationIF hitX2/24 <> 23 AND hitX2/24 <> 24 //right x location//starting coordinates for spikeLET spikeMoving1X1 = 25LET spikeMoving1X2 = 48LET spikeMoving1Y1 = 97LET spikeMoving1Y2 = 168//print the spikes.pictH = fn ResourceImageToPICTHandle( @"Many spike RIGHT.png", @r )picture (spikeMoving1X1, spikeMoving1Y1) - (spikeMoving1X2, spikeMoving1Y2), pictHfn DisposeH( pictH )//set the boolean variables to start the spike moving processLET spikeMoving = "yep"LET triggered = "lvl1spike1"END IFEND IFEND IFIF level = 1 AND triggered = "na" AND spikeGoBack2 <> "yep2" LET currenttriggerY = hitY2/24IF currenttriggerY = 11IF hitX2/24 <> 2 AND hitX2/24 <> 3 //right x location//starting coordinates for spikeLET spikeMoving2X1 = 552LET spikeMoving2X2 = 576LET spikeMoving2Y1 = 193LET spikeMoving2Y2 = 264//print the spikes.pictH = fn ResourceImageToPICTHandle( @"Many spike LEFT.png", @r )picture (spikeMoving2X1, spikeMoving2Y1) - (spikeMoving2X2, spikeMoving2Y2), pictHfn DisposeH( pictH )//set the boolean variables to start the spike moving processLET spikeMoving = "yep"LET triggered = "lvl1spike2"COLOR _zWhite BOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2END IFEND IFEND IFIF level = 1 AND triggered = "na"LET currenttriggerY = hitY2/24IF currenttriggerY = 15IF hitX2/24 = 20 OR hitX2/24 = 21 OR hitX2/24 = 22//right x location//starting coordinates for spikeLET spikeMoving3X1 = 552LET spikeMoving3X2 = 576LET spikeMoving3Y1 = 289LET spikeMoving3Y2 = 360//print the spikes.pictH = fn ResourceImageToPICTHandle( @"Many spike LEFT.png", @r )picture (spikeMoving3X1, spikeMoving3Y1) - (spikeMoving3X2, spikeMoving3Y2), pictHfn DisposeH( pictH )//set the boolean variables to start the spike moving processLET spikeMoving = "yep"LET triggered = "lvl1spike3"COLOR _zWhite BOX FILL spikeMoving3X1, spikeMoving3Y1 TO spikeMoving3X2, spikeMoving3Y2END IFEND IFEND IFIF level = 1IF triggered = "lvl1spike1" OR triggered = "lvl1spike1" OR spikeGoBack1 = "yep1" OR spikeGoBack2 = "yep2"IF hitX1 <= spikeMoving1X2 AND hitX1 >= spikeMoving1X1 AND hitY1 <= spikeMoving1Y2 AND hitY2 >= spikeMoving1Y1LET death = "yep"END IFEND IFEND IFIF level = 1IF triggered = "lvl1spike1" OR triggered = "lvl1spike1" OR spikeGoBack1 = "yep1" OR spikeGoBack2 = "yep2"IF hitX1 <= spikeMoving2X2 AND hitX1 >= spikeMoving2X1 AND hitY1 <= spikeMoving2Y2 AND hitY2 >= spikeMoving2Y1LET death = "yep"END IFEND IFEND IFIF level = 1IF triggered = "lvl1spike1" OR triggered = "lvl1spike1" OR spikeGoBack1 = "yep1" OR spikeGoBack2 = "yep2"IF hitX1 <= spikeMoving3X2 AND hitX1 >= spikeMoving3X1 AND hitY1 <= spikeMoving3Y2 AND hitY2 >= spikeMoving3Y1LET death = "yep"END IFEND IFEND IFIF death = "yep"GOSUB "suck"LET death = "na"COLOR _zWhiteBOX FILL hitX1,hitY1 TO hitX2,hitY2LET hitX1 = spawnLocX1LET hitX2 = spawnLocX2LET hitY1 = spawnLocY1LET hitY2 = spawnLocY2LET spikeMoving = "na"LET triggered = "na"LET spikeGoBack1 = "na"LET spikeGoBack2 = "na"LET spikeMoving1X1 = 0LET spikeMoving1X2 = 0LET spikeMoving1Y1 = 0LET spikeMoving1Y2 = 0LET spikeMoving2X1 = 0LET spikeMoving2X2 = 0LET spikeMoving2Y1 = 0LET spikeMoving2Y2 = 0LET spikeMoving3X1 = 0LET spikeMoving3X2 = 0LET spikeMoving3Y1 = 0LET spikeMoving3Y2 = 0END IFIF bul1X <> 0 //this means if the bullet exists aka the shot has been initiatedSELECT levelCASE 1IF blocks1(bul1X/24 + 1,(bul1Y - 12)/24 + 1) <> "brick" //if the block where the bullet is located currently is NOT a brickIF bulDir1 = "" // if the bullet doesnt have a direction yet meaning it is the begining of the shot (just after you press shoot)SELECT lastDir //select the last direction of the player and set the bullet direction accordinglylCASE "a"LET bulDir1 = "left"CASE "d"LET bulDir1 = "right"END SELECTEND IF//fill in previous position with white dot.COLOR _zWhiteCIRCLE FILL bul1X,bul1Y, 5//moving the bulletSELECT bulDir1//adding pixels to coordinates accordingly.CASE "left"bul1X -= 6CASE "right"bul1X += 6END SELECT//printing bulletCOLOR _zCyanCIRCLE FILL bul1X,bul1Y, 5IF blocks1(bul1X/24 + 1,(bul1Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSE//if the bullet has hit something.LET bulDir1 = "" //reset bullet direction.//filling in with whiteCOLOR _zWhiteCIRCLE FILL bul1X,bul1Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul1X/24 + 1)*24)-24LET replacementBlockY1 = (((bul1Y - 12)/24)*24)LET replacementBlockX2 = ((bul1X/24 + 1)*24)LET replacementBlockY2 = (((bul1Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )//reset coordinatesLET bul1X = 0LET bul1Y = 0END IFCASE 2IF blocks2(bul1X/24 + 1,(bul1Y - 12)/24 + 1) <> "brick" //if the block where the bullet is located currently is NOT a brickIF bulDir1 = "" // if the bullet doesnt have a direction yet meaning it is the begining of the shot (just after you press shoot)SELECT lastDir //select the last direction of the player and set the bullet direction accordinglyCASE "a"LET bulDir1 = "left"CASE "d"LET bulDir1 = "right"END SELECTEND IF//fill in previous position with white dot.COLOR _zWhiteCIRCLE FILL bul1X,bul1Y, 5//moving the bulletSELECT bulDir1//adding pixels to coordinates accordingly.CASE "left"bul1X -= 6CASE "right"bul1X += 6END SELECT//printing bulletCOLOR _zCyanCIRCLE FILL bul1X,bul1Y, 5IF blocks2(bul1X/24 + 1,(bul1Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSE//if the bullet has hit something.LET bulDir1 = "" //reset bullet direction.//filling in with whiteCOLOR _zWhiteCIRCLE FILL bul1X,bul1Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul1X/24 + 1)*24)-24LET replacementBlockY1 = (((bul1Y - 12)/24)*24)LET replacementBlockX2 = ((bul1X/24 + 1)*24)LET replacementBlockY2 = (((bul1Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )//reset coordinatesLET bul1X = 0LET bul1Y = 0END IFEND SELECTEND IF//SAME AS ABOVE FOR THE SECOND BULLETIF bul2X <> 0 SELECT levelCASE 1IF blocks1(bul2X/24 + 1,(bul2Y - 12)/24 + 1) <> "brick"IF bulDir2 = ""SELECT lastDirCASE "a"LET bulDir2 = "left"CASE "d"LET bulDir2 = "right"END SELECTEND IFCOLOR _zWhiteCIRCLE FILL bul2X,bul2Y, 5SELECT bulDir2CASE "left"bul2X -= 6CASE "right"bul2X += 6END SELECTCOLOR _zCyanCIRCLE FILL bul2X,bul2Y, 5IF blocks1(bul2X/24 + 1,(bul2Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSELET bulDir2 = ""COLOR _zWhiteCIRCLE FILL bul2X,bul2Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul2X/24 + 1)*24)-24LET replacementBlockY1 = (((bul2Y - 12)/24)*24)LET replacementBlockX2 = ((bul2X/24 + 1)*24)LET replacementBlockY2 = (((bul2Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )LET bul2X = 0LET bul2Y = 0//PRINT % (100,100) bul1X,bul1Y,bul1FlagEND IFCASE 2IF blocks2(bul2X/24 + 1,(bul2Y - 12)/24 + 1) <> "brick"IF bulDir2 = ""SELECT lastDirCASE "a"LET bulDir2 = "left"CASE "d"LET bulDir2 = "right"END SELECTEND IFCOLOR _zWhiteCIRCLE FILL bul2X,bul2Y, 5SELECT bulDir2CASE "left"bul2X -= 6CASE "right"bul2X += 6END SELECTCOLOR _zCyanCIRCLE FILL bul2X,bul2Y, 5IF blocks2(bul2X/24 + 1,(bul2Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSELET bulDir2 = ""COLOR _zWhiteCIRCLE FILL bul2X,bul2Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul2X/24 + 1)*24)-24LET replacementBlockY1 = (((bul2Y - 12)/24)*24)LET replacementBlockX2 = ((bul2X/24 + 1)*24)LET replacementBlockY2 = (((bul2Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )LET bul2X = 0LET bul2Y = 0//PRINT % (100,100) bul1X,bul1Y,bul1FlagEND IFEND SELECTEND IF//SAME AS ABOVE FOR THE THRID BULLETIF bul3X <> 0 SELECT levelCASE 1IF blocks1(bul3X/24 + 1,(bul3Y - 12)/24 + 1) <> "brick"IF bulDir3 = ""SELECT lastDirCASE "a"LET bulDir3 = "left"CASE "d"LET bulDir3 = "right"END SELECTEND IFCOLOR _zWhiteCIRCLE FILL bul3X,bul3Y, 5SELECT bulDir3CASE "left"bul3X -= 6CASE "right"bul3X += 6END SELECTCOLOR _zCyanCIRCLE FILL bul3X,bul3Y, 5IF blocks1(bul3X/24 + 1,(bul3Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSELET bulDir3 = ""COLOR _zWhiteCIRCLE FILL bul3X,bul3Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul3X/24 + 1)*24)-24LET replacementBlockY1 = (((bul3Y - 12)/24)*24)LET replacementBlockX2 = ((bul3X/24 + 1)*24)LET replacementBlockY2 = (((bul3Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )LET bul3X = 0LET bul3Y = 0END IFCASE 2IF blocks2(bul3X/24 + 1,(bul3Y - 12)/24 + 1) <> "brick"IF bulDir3 = ""SELECT lastDirCASE "a"LET bulDir3 = "left"CASE "d"LET bulDir3 = "right"END SELECTEND IFCOLOR _zWhiteCIRCLE FILL bul3X,bul3Y, 5SELECT bulDir3CASE "left"bul3X -= 6CASE "right"bul3X += 6END SELECTCOLOR _zCyanCIRCLE FILL bul3X,bul3Y, 5IF blocks2(bul3X/24 + 1,(bul3Y - 12)/24 + 1) = "save-"IF active1 = _FALSEGOSUB "green"END IFIF active2 = _FALSEGOSUB "green"END IFEND IFELSELET bulDir3 = ""COLOR _zWhiteCIRCLE FILL bul3X,bul3Y,5//setting variable to the block where the bullet stoppedLET replacementBlockX1 = ((bul3X/24 + 1)*24)-24LET replacementBlockY1 = (((bul3Y - 12)/24)*24)LET replacementBlockX2 = ((bul3X/24 + 1)*24)LET replacementBlockY2 = (((bul3Y - 12)/24)*24)+24//reprinting the brick where the bullet stoppedpictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )picture ( replacementBlockX1,replacementBlockY1 ) - ( replacementBlockX2, replacementBlockY2), pictHfn DisposeH( pictH )LET bul3X = 0LET bul3Y = 0END IFEND SELECTEND IF//if the block below you is not a brick and you aren't in the airSELECT levelCASE 1IF blocks1(hitX1/24 + 1,hitY2/24 + 1) <> "brick" AND upDown = ""//fill your location in with white boxCOLOR _zWhiteBOX FILL hitX1,hitY1 TO hitX2,hitY2//move downhitY1 += 12hitY2 += 12//printing the character based on which was you were facing last.SELECT lastDirCASE "a"pictH = fn ResourceImageToPICTHandle( @"The kid LEFT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )CASE "d"pictH = fn ResourceImageToPICTHandle( @"The kid RIGHT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )END SELECTEND IFCASE 2IF blocks2(hitX1/24 + 1,hitY2/24 + 1) <> "brick" AND upDown = ""//fill your location in with white boxCOLOR _zWhiteBOX FILL hitX1,hitY1 TO hitX2,hitY2//move downhitY1 += 12hitY2 += 12//printing the character based on which was you were facing last.SELECT lastDirCASE "a"pictH = fn ResourceImageToPICTHandle( @"The kid LEFT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )CASE "d"pictH = fn ResourceImageToPICTHandle( @"The kid RIGHT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )END SELECTEND IFEND SELECT//reseting input variableLET inkey = ""//loop cycle is the amount of times the loop has run.//we only collect input from the keyboard every 3 runs of the loop because otherwise the program is too slow due to many inkeys (slightly delays the program)loopCycle ++//starts at 0 so 2 is the 3rd run.IF loopCycle = 2LET loopCycle = 0 //reset countLET inkey = INKEY$//take input//if there is input:IF inkey <> ""//inkeyfill is basically a boolean saying either there is something or not in the input variable.LET inkeyFill = "yup"SELECT inkeyCASE " " // if the user clicked the space barLET jumpNo += 1// add one to the number of jumps (this is a counter so we can limit to double jump)IF jumpNo <= 2// if you have jumps leftLET heightCounter = 0//heightcounter is the amount of times the player has moved either up or down (one movement per cycle)LET upDown = "up"//set the 'boolean' updown variable to go up to jumpIF jumpNo = 1// if its the first jump.LET tempJump = hitY1//set the current location to tempjump which is the spot you started the jump.END IFEND IFCASE "a"LET leftRight = "a"//if the user choses to move left of right - a or dCASE "d"LET leftRight = "d"CASE "m"// m for shooting.GOSUB "bullet 123"END SELECTLET inkey = ""END IFEND IFELSEIF hitY1 <= 0 AND level = 1LET level = 2//starting position for characterLET hitX1 = 144LET hitX2 = 168LET hitY1 = 408LET hitY2 = 432GOSUB "Draw"LET triggered = "na"LET spikeGoBack1 = "na"LET spikeGoBack2 = "na"COLOR _zWhiteBOX FILL spikeMoving1X1, spikeMoving1Y1 TO spikeMoving1X2, spikeMoving1Y2COLOR _zWhiteBOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2END IFIF hitY2 >= 450 AND level = 2LET level = 1//starting position for characterLET hitX1 = 25LET hitX2 = 48LET hitY1 = 49LET hitY2 = 72GOSUB "Draw"LET triggered = "na"LET spikeGoBack1 = "na"LET spikeGoBack2 = "na"COLOR _zWhiteBOX FILL spikeMoving1X1, spikeMoving1Y1 TO spikeMoving1X2, spikeMoving1Y2COLOR _zWhiteBOX FILL spikeMoving2X1, spikeMoving2Y1 TO spikeMoving2X2, spikeMoving2Y2END IFEND IFIF level = 1activeCounter++IF active1 = _TRUEpictH = fn ResourceImageToPICTHandle( @"Save GREEN.png", @r )picture ( 2*24,24 ) - ( 3*24, 2*24), pictHfn DisposeH( pictH )END IFIF active2 = _TRUEpictH = fn ResourceImageToPICTHandle( @"Save GREEN.png", @r )picture (2*24,13*24 ) - ( 3*24, 14*24), pictHfn DisposeH( pictH )END IFIF activeCounter = 80LET active1 = _FALSEpictH = fn ResourceImageToPICTHandle( @"Save RED.png", @r )picture ( 2*24,24 ) - ( 3*24, 2*24), pictHfn DisposeH( pictH )LET active2 = _FALSEpictH = fn ResourceImageToPICTHandle( @"Save RED.png", @r )picture (2*24,13*24 ) - ( 3*24, 14*24), pictHfn DisposeH( pictH )LET activeCounter = 0END IFEND IFUNTIL game = "over"/*LET fPath3 = OSPANELSAVE(,@"Save Score", @"txt",@"Open",)OPEN "O",3, @fPath3WRITE #3, spawnLocX1, spawnLocX2, spawnLocY1, spawnLocY2CLOSE #3*/STOP"green"IF hitY1 < 300 AND active1 = _FALSEpictH = fn ResourceImageToPICTHandle( @"Save GREEN.png", @r )picture ( 2*24,24 ) - ( 3*24, 2*24), pictHLET spawnLocX1 = hitX1LET spawnLocX2 = hitX2LET spawnLocY1 = hitY1LET spawnLocY2 = hitY2LET active1 = _TRUEOPEN "O",3, @fPath3WRITE #3, spawnLocX1, spawnLocX2, spawnLocY1, spawnLocY2CLOSE #3END IFIF hitY1 > 300 AND active2 = _FALSEpictH = fn ResourceImageToPICTHandle( @"Save GREEN.png", @r )picture (2*24,13*24 ) - ( 3*24, 14*24), pictHLET spawnLocX1 = hitX1LET spawnLocX2 = hitX2LET spawnLocY1 = hitY1LET spawnLocY2 = hitY2LET active2 = _TRUEOPEN "O",3, @fPath3WRITE #3, spawnLocX1, spawnLocX2, spawnLocY1, spawnLocY2CLOSE #3END IFfn DisposeH( pictH )RETURN"bullet 123"// if the bullet is just being initiatedIF bul1X = 0LET bul1X = hitX1 //set starting location for bullet to the current location of the characterLET bul1Y = (hitY1 + hitY2)/2 RETURNEND IF// if the 1st bullet has been shot and the second hasnt yetIF bul1X <> 0 AND bul2X = 0LET bul2X = hitX1 //set starting location for bullet to the current location of the characterLET bul2Y = (hitY1 + hitY2)/2RETURNEND IF// if the 1st and second bullets have been shot and the third hasntIF bul1X <> 0 AND bul2X <> 0 AND bul3X = 0LET bul3X = hitX1 //set starting location for bullet to the current location of the charactetrLET bul3Y = (hitY1 + hitY2)/2RETURNEND IFRETURN"Draw"CLS//drawing backdrop painting images going through entire array.FOR index2 = 1 TO 19 STEP 1FOR index1 = 1 TO 25 STEP 1SELECT levelCASE 1SELECT blocks1(index1,index2)CASE "brick"pictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )CASE "save-"pictH = fn ResourceImageToPICTHandle( @"Save RED.png", @r )CASE "apple"pictH = fn ResourceImageToPICTHandle( @"Apple.png", @r)END SELECTIF blocks1(index1,index2) <> "air--"picture ((index1 - 1)*24,(index2 - 1)*24) - (((index1 - 1)*24)+25,((index2 - 1)*24)+25), pictHfn DisposeH( pictH )END IFCASE 2SELECT blocks2(index1,index2)CASE "brick"pictH = fn ResourceImageToPICTHandle( @"Dirt block.png", @r )CASE "save-"pictH = fn ResourceImageToPICTHandle( @"Save RED.png", @r )CASE "apple"pictH = fn ResourceImageToPICTHandle( @"Apple.png", @r)END SELECTIF blocks2(index1,index2) <> "air--"picture ((index1 - 1)*24,(index2 - 1)*24) - (((index1 - 1)*24)+25,((index2 - 1)*24)+25), pictHfn DisposeH( pictH )END IFEND SELECTNEXTNEXT/*pictH = fn ResourceImageToPICTHandle( @"1st stage background.png", @r )picture ( 0,0 ) - ( 500, 500), pictHfn DisposeH( pictH )*///drawing characterpictH = fn ResourceImageToPICTHandle( @"The kid RIGHT.png", @r )picture ( hitX1,hitY1 ) - ( hitX2, hitY2), pictHfn DisposeH( pictH )RETURN"suck"LONG COLOR (179*257),(192*257),(196*257)TEXT ,50,,_TransparentPRINT % (135,200) "Wow, you suck"TEXT ,30,,_TransparentPRINT % (160,300) "Press r to respawn"DOLET inkey = INKEY$UNTIL inkey = "r"GOSUB "Draw"RETURN